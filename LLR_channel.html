<p><strong>Οδηγίες για το AWGN κανάλι με BPSK διαμόρφωση υλοποιημένο σε VHDL</strong></p>

<hr>

<p>Βασικά η παρακάτω αναφορά δεν έχει σκοπό να δείξει την αρχη λειτουργία του component LLR channel αλλά το τρόπο και τους χρονισκούς του , ώστε να κατασκευαστεί ένα FMS απλά και γρήγορα.</p>

<p>Αρχικά αυτό το component απαρτίζεται από επιμέρους component. Ο θόρυβος θα πρέπει να μπαίνει σε κάθε bit της κωδικοποιμένης λέξης και η έξοδος θα πρέπει να είναι ένας πίνακας όπου η μια διάσταση είναι ίση με το μήκος της εισόδου και η άλλη διάσταση είνια το πλήθος των bits που εκφράζουν το εν λόγω LLR ενός bit.</p>

<p>Για να μπεί θόρυβος σε κάθε bit της λέξης εισόφου θα πρέπει να γίνει parallel-2-serial και αυτό γίνεται με το component mux το οποίο παίρνει σαν είσοδο την κωδική λέξη και βγάζει 2 bits (llr2bit) αυτής σε κάθε clk. ΤΟ σήμα llr2bit θα μπει σαν είσοδο στο component <em>mysystem</em> το οποίο θα παράξει το διαμορφωμένο σύμβολο για κάθε bit με διαμόρφωση BPSK. <br>
Η διαμόρφωση BPSK είνια γνωστό ότι μπορεί να περιγραφεί με την εξίσωση  <br>
<script type="math/tex; mode=display" id="MathJax-Element-3350">BPSK = 1 - 2 X</script> , X είναι ένα bot της κωδικοποιημένης λέξης.</p>

<p>Η σχέση που υπολογίζει τα LLR είναι  <script type="math/tex" id="MathJax-Element-3351">2y/σ^{2} ,	y=x+σ </script></p>

<p>Οι τιμές των σ και <script type="math/tex" id="MathJax-Element-3352">σ^{2}</script> , για διάφορες στάθμες θορύβου έχουν υπολογιστεί μέσω <em>Matlab</em> και έχουν εισαχθεί σε ένα LUT (snrlut.vhd), όπου για κάθε στάθμη θορύβου αξάγωνται αυτές οι δύο ποσότητες και χρησιμοποιούνται από το “<em>mysystem.vhd</em>“. <br>
Για λόγους debugging για 0dB έχει οριστεί το  <script type="math/tex" id="MathJax-Element-3353">σ=0</script> και το <script type="math/tex" id="MathJax-Element-3354">σ^{2}=-1</script>,  το οποίο θα παράξει LLR μέγιστης αξιοπιστίας και ο decoder θα βρει την κωδική λέξη χωρίς κανένα λάθος. Αν στην ίδια περίπτωση το <script type="math/tex" id="MathJax-Element-3355">σ=1</script> με αντίστοιχο format (8.32) αναμένεται να γίνει μέτρηση στο 0dB SNR.</p>

<p>Έχοντας το <script type="math/tex" id="MathJax-Element-3356">σ=0 </script> και το <script type="math/tex" id="MathJax-Element-3357">σ^{2}=-1</script> θα πρέπει η διαμόρφωση να γίνεται όχι όπως αναφέρεται παραπάνω, αλλα <script type="math/tex; mode=display" id="MathJax-Element-3358">BPSK = 2X - 1</script>.</p>

<p>Το parallel-2-serial γίνεται χρησιμοποιώντας έναν counter του οποίου η έξοδος θα χρησιμοποιηθεί για να επιλεχθεί στο <em>mux.vhd</em> σε ποια δυάδα bits θα προστεθεί θόρυβος. Επομένως αν ο counter έχει στην έξοδο του τη τιμή 5, το 10 και το 11 bit της λέξης εισόδου θα επιλεχθεί για να του προστεθεί θόρυβος. <br>
Η αντίστροφη διαδικασία γίνεται και για την έξοδο, όπου κάθε φορά υπολογίζονται τα llr1 και llr2 από το <em>mysystem</em>, δηλαδή όταν παραχθεί ένα ζεύγος από llr θα αποθηκευτούν σε έναν register-file, όπου το σήμα enable για κάθε καταχωρητή παράγεταθ από έναν shift-register. O shift-register θα πρέπει να γίνει enable για <strong>ένα clk και μόνο</strong> καθώς σε κάθε clk πρέπει να ενεργοποιείται μόνο ένας καταχωρητής του register-file. Όταν τελειώσει το shifting και μόνο τότε είναι σωστά τα llr και έτοιμα για το decoder.</p>

<p>Το component “LLR_channel” έχει σαν είσοδο όπως αναφέρθηκε παραπάνω την λέξη εισόδου, llr_count_en  : ενεργοποιεί τον </p>

<ul>
<li>llr_counter  για το parallel-2-serial</li>
<li>dinredy   : να είναι μόνιμα στο ‘1’</li>
<li>start_shift   : ενεργοποιει το shift, να γίνει ‘1’ για ένα clk μονο</li>
<li>SNR       : σταθμη θορύβου</li>
<li>llr_counter   : ο counter για το p-2-s</li>
<li>shift_reg : </li>
<li>readyout  : όταν γίνει ‘1’ μετά το rst του συστήματος, τοτε μπορεί να βγάλει σωστά LLR</li>
</ul>

<p>Το πρόβλημα που γεννιέται είναι τότε θα πρέπει να γίνει το llr_count_en =’1’ και πότε το start_shift=’1’, τα οποία σήματα θα πρέπει να ελέγχονται από την FSM. <br>
Όταν  είναι έτοιμη η κωδικοποιημένη λέξη και διαθέσιμη στην είσοδο του καναλιού θα πρέπει να γίνει στο επόμενο clk  το llr_count_en =’1’. <br>
Θα πρέπει όταν γίνει ο llr_counter = “7”  θα πρεπει να γίνει το start_shift =’1’ για ένα clk. <br>
Το πιο σημαντικό είναι ότι δεν θα πρέπει ο llr_counter να πάθει overflow ενώ γίνεται shifting. Άρα θα  πρέπει να παραμείνει στην τιμή “FF” (το πόσα F εξαρτάται απο το μήκος της λέξης), μέχρι να είναι διαθέσιμη η επόμενη κωδικοποιημενη λέξη ή να μην χρειάζεστε άλλο τα LLR.</p>

<p>Το πως θα γίνει η παραπάνω διαδικασία είναι στην δικιά σας ευχέρια για το γράψιμο της FSM.</p>